√<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Node.js 대화형 학습 가이드</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Chosen Palette: Calm Tech Neutral -->
    <!-- Application Structure Plan: 본 보고서의 내용을 단순한 스크롤 방식이 아닌, 주제별 대화형 모듈로 재구성했습니다. 사용자는 상단 네비게이션을 통해 '기초 개념', '핵심 아키텍처', '생태계', '학습 로드맵', '자주하는 실수' 등 원하는 주제로 바로 이동할 수 있습니다. 특히 '핵심 아키텍처' 섹션에서는 이벤트 루프의 동작을 시각적으로 시뮬레이션하여, 텍스트만으로는 이해하기 어려운 비동기 처리 과정을 직관적으로 학습할 수 있도록 설계했습니다. 이러한 구조는 사용자가 자신의 학습 속도에 맞춰 필요한 정보를 능동적으로 탐색하게 함으로써 학습 효과를 극대화하기 위해 선택되었습니다. -->
    <!-- Visualization & Content Choices: 
        - 보고서 정보: Node.js와 브라우저의 차이점 -> 목표: 비교 -> 표현 방식: 대화형 카드 -> 상호작용: 클릭 시 상세 내용 표시 -> 정당성: 정적인 표보다 각 항목에 집중하게 하여 가독성을 높임.
        - 보고서 정보: 이벤트 루프 동작 원리 -> 목표: 복잡한 프로세스 설명 -> 표현 방식: HTML/CSS/JS 기반 애니메이션 시뮬레이션 -> 상호작용: '비동기 작업 실행' 버튼 클릭 시 애니메이션 재생 -> 정당성: Node.js의 가장 핵심적이고 추상적인 개념을 시각화하여, 텍스트 기반 학습의 한계를 극복하고 직관적인 이해를 도움.
        - 보고서 정보: I/O-Bound vs CPU-Bound -> 목표: 비교 -> 표현 방식: Bar Chart (Chart.js) -> 상호작용: 차트 호버 시 툴팁으로 설명 표시 -> 정당성: 두 작업 유형에 따른 성능 차이를 정량적으로 보여주어 Node.js의 강점을 명확히 전달함.
        - 보고서 정보: 학습 로드맵 -> 목표: 단계별 정보 제공 -> 표현 방식: 대화형 스텝퍼(Stepper) -> 상호작용: 각 단계 클릭 시 해당 내용 표시 -> 정당성: 학습 과정을 시각적으로 안내하여 사용자가 체계적으로 정보를 습득하도록 유도함.
        - 보고서 정보: 초보자의 흔한 실수 -> 목표: 정보 조직화 -> 표현 방식: 아코디언 UI -> 상호작용: 각 항목 클릭 시 내용 펼침/접힘 -> 정당성: 정보를 깔끔하게 그룹화하고 사용자가 관심 있는 부분만 선택적으로 볼 수 있게 하여 정보 과부하를 방지함.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8f9fa;
            color: #212529;
        }
        @import url('https://rsms.me/inter/inter.css');
        .nav-link {
            transition: color 0.3s, border-bottom-color 0.3s;
            border-bottom: 2px solid transparent;
        }
        .nav-link.active, .nav-link:hover {
            color: #0d6efd;
            border-bottom-color: #0d6efd;
        }
        .section-card {
            background-color: white;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            transition: transform 0.3s, box-shadow 0.3s;
        }
        .section-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -2px rgb(0 0 0 / 0.1);
        }
        .event-loop-component {
            border: 1px solid #e5e7eb;
            padding: 1rem;
            border-radius: 0.5rem;
            min-height: 120px;
            background-color: #f9fafb;
        }
        .task {
            background-color: #3b82f6;
            color: white;
            padding: 0.5rem;
            border-radius: 0.375rem;
            margin-bottom: 0.5rem;
            text-align: center;
            font-size: 0.875rem;
            transition: all 0.5s ease-in-out;
        }
        .fade-in {
            animation: fadeIn 0.5s forwards;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out;
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            height: 300px;
            max-height: 400px;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 350px;
            }
        }
    </style>
</head>
<body class="bg-gray-50">

    <header class="bg-white/80 backdrop-blur-md sticky top-0 z-50 shadow-sm">
        <nav class="container mx-auto px-6 py-4 flex justify-between items-center">
            <h1 class="text-2xl font-bold text-gray-800">Node.js 학습 가이드</h1>
            <div class="hidden md:flex space-x-8">
                <a href="#introduction" class="nav-link text-gray-600 font-medium pb-1">Node.js란?</a>
                <a href="#architecture" class="nav-link text-gray-600 font-medium pb-1">핵심 아키텍처</a>
                <a href="#ecosystem" class="nav-link text-gray-600 font-medium pb-1">생태계</a>
                <a href="#roadmap" class="nav-link text-gray-600 font-medium pb-1">학습 로드맵</a>
                <a href="#mistakes" class="nav-link text-gray-600 font-medium pb-1">자주하는 실수</a>
            </div>
            <button id="mobile-menu-button" class="md:hidden focus:outline-none">
                <span class="text-3xl">☰</span>
            </button>
        </nav>
        <div id="mobile-menu" class="hidden md:hidden px-6 pb-4 space-y-2">
            <a href="#introduction" class="block nav-link text-gray-600 font-medium py-2">Node.js란?</a>
            <a href="#architecture" class="block nav-link text-gray-600 font-medium py-2">핵심 아키텍처</a>
            <a href="#ecosystem" class="block nav-link text-gray-600 font-medium py-2">생태계</a>
            <a href="#roadmap" class="block nav-link text-gray-600 font-medium py-2">학습 로드맵</a>
            <a href="#mistakes" class="block nav-link text-gray-600 font-medium py-2">자주하는 실수</a>
        </div>
    </header>

    <main class="container mx-auto px-6 py-12">

        <section id="introduction" class="mb-20 scroll-mt-20">
            <h2 class="text-3xl font-bold text-center mb-4">Node.js의 본질: 개념과 탄생 배경</h2>
            <p class="text-center text-gray-600 max-w-3xl mx-auto mb-12">Node.js는 브라우저를 넘어 서버 환경에서 자바스크립트를 실행하게 해주는 강력한 '런타임 환경'입니다. 이 섹션에서는 Node.js의 기본 정의와 핵심 철학, 그리고 브라우저 환경과의 차이점을 통해 Node.js의 정체성을 알아봅니다.</p>
            
            <div class="grid md:grid-cols-2 gap-8">
                <div class="section-card p-6">
                    <h3 class="text-xl font-bold mb-3">🚀 Node.js란 무엇인가?</h3>
                    <p class="text-gray-700">Node.js는 Google의 V8 자바스크립트 엔진을 기반으로, 서버 사이드 애플리케이션 개발을 위해 탄생했습니다. 자바스크립트 하나로 프론트엔드와 백엔드를 모두 다룰 수 있게 하여 개발 생태계에 큰 변화를 가져왔습니다.</p>
                </div>
                <div class="section-card p-6">
                    <h3 class="text-xl font-bold mb-3">💡 핵심 철학: 비동기 논블로킹 I/O</h3>
                    <p class="text-gray-700">Node.js는 '단일 스레드'와 '이벤트 기반 비동기 논블로킹 I/O' 모델을 채택했습니다. 이 구조는 I/O 작업이 많은 애플리케이션에서 적은 자원으로도 수많은 동시 요청을 효율적으로 처리할 수 있게 해주는 핵심 비결입니다.</p>
                </div>
            </div>

            <div class="mt-12">
                <h3 class="text-2xl font-bold text-center mb-6">Node.js vs 웹 브라우저</h3>
                <div class="bg-white rounded-lg shadow-md p-6 max-w-4xl mx-auto">
                     <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-center">
                        <div>
                            <div class="font-bold text-lg p-3 bg-gray-100 rounded-t-lg">특징</div>
                            <div class="p-3 border-t">런타임 환경</div>
                            <div class="p-3 border-t bg-gray-50">주요 API</div>
                            <div class="p-3 border-t">목적</div>
                        </div>
                        <div>
                            <div class="font-bold text-lg p-3 bg-blue-100 rounded-t-lg text-blue-800">Node.js</div>
                            <div class="p-3 border-t">서버 사이드</div>
                            <div class="p-3 border-t bg-gray-50">파일 시스템, 네트워크, OS 접근</div>
                            <div class="p-3 border-t">백엔드 서버, API 개발</div>
                        </div>
                        <div>
                            <div class="font-bold text-lg p-3 bg-green-100 rounded-t-lg text-green-800">웹 브라우저</div>
                            <div class="p-3 border-t">클라이언트 사이드</div>
                            <div class="p-3 border-t bg-gray-50">DOM 조작, 윈도우, UI 이벤트</div>
                            <div class="p-3 border-t">웹페이지 렌더링, 사용자 상호작용</div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <hr class="my-16 border-gray-200">

        <section id="architecture" class="mb-20 scroll-mt-20">
            <h2 class="text-3xl font-bold text-center mb-4">Node.js의 심장부: 내부 아키텍처</h2>
            <p class="text-center text-gray-600 max-w-3xl mx-auto mb-12">Node.js의 뛰어난 성능은 독특한 내부 아키텍처에서 비롯됩니다. 이 섹션에서는 V8 엔진, 이벤트 루프, 그리고 libuv가 어떻게 상호작용하여 비동기 작업을 처리하는지 시각적인 시뮬레이션을 통해 깊이 있게 탐구합니다.</p>

            <div class="section-card p-8">
                <h3 class="text-2xl font-bold mb-6 text-center">이벤트 루프 시뮬레이션</h3>
                <div class="grid md:grid-cols-3 gap-6 text-center">
                    <div>
                        <h4 class="font-bold mb-2">1. Call Stack</h4>
                        <div id="call-stack" class="event-loop-component"></div>
                    </div>
                    <div>
                        <h4 class="font-bold mb-2">2. Web APIs (libuv)</h4>
                        <div id="web-apis" class="event-loop-component"></div>
                    </div>
                    <div>
                        <h4 class="font-bold mb-2">3. Callback Queue</h4>
                        <div id="callback-queue" class="event-loop-component"></div>
                    </div>
                </div>
                <div class="text-center mt-6">
                    <button id="run-simulation" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg transition-colors">비동기 작업 실행</button>
                </div>
                <p id="simulation-log" class="mt-4 text-sm text-gray-500 text-center h-5"></p>
            </div>
            
            <div class="mt-12">
                <h3 class="text-2xl font-bold text-center mb-6">I/O-Bound vs CPU-Bound 작업 효율성</h3>
                 <p class="text-center text-gray-600 max-w-3xl mx-auto mb-8">Node.js는 파일 읽기/쓰기, 네트워크 요청과 같은 I/O-Bound 작업에 최적화되어 있습니다. 메인 스레드를 막지 않고 백그라운드에서 작업을 처리하기 때문입니다. 반면, 복잡한 연산 같은 CPU-Bound 작업은 메인 스레드를 점유하여 성능 저하를 유발할 수 있습니다.</p>
                <div class="chart-container">
                    <canvas id="performanceChart"></canvas>
                </div>
            </div>
        </section>

        <hr class="my-16 border-gray-200">

        <section id="ecosystem" class="mb-20 scroll-mt-20">
            <h2 class="text-3xl font-bold text-center mb-4">Node.js 생태계의 기초</h2>
            <p class="text-center text-gray-600 max-w-3xl mx-auto mb-12">강력한 생태계는 Node.js의 가장 큰 자산입니다. 모듈 시스템을 통해 코드를 재사용하고, NPM(Node Package Manager)을 이용해 전 세계 개발자들이 만든 수많은 패키지를 손쉽게 활용하는 방법을 알아봅니다.</p>
            <div class="grid md:grid-cols-3 gap-8">
                <div class="section-card p-6">
                    <h3 class="text-xl font-bold mb-3">📦 모듈 시스템</h3>
                    <p class="text-gray-700">Node.js는 각 파일을 독립된 모듈로 취급합니다. `require`로 다른 모듈을 가져오고, `module.exports`로 기능을 외부에 공개하는 CommonJS 방식을 통해 코드의 재사용성과 관리 효율성을 높입니다.</p>
                </div>
                <div class="section-card p-6">
                    <h3 class="text-xl font-bold mb-3">🌐 NPM (Node Package Manager)</h3>
                    <p class="text-gray-700">NPM은 세계 최대의 소프트웨어 레지스트리입니다. `npm install` 명령어 하나로 필요한 라이브러리를 설치하고, `package.json` 파일을 통해 프로젝트 의존성을 체계적으로 관리할 수 있습니다.</p>
                </div>
                <div class="section-card p-6">
                    <h3 class="text-xl font-bold mb-3">🛠️ 내장 모듈</h3>
                    <p class="text-gray-700">파일 시스템을 다루는 `fs`, 경로를 조작하는 `path`, HTTP 서버를 만드는 `http` 등 필수적인 기능들이 내장 모듈로 제공되어, 별도 설치 없이 강력한 기능을 바로 사용할 수 있습니다.</p>
                </div>
            </div>
        </section>

        <hr class="my-16 border-gray-200">

        <section id="roadmap" class="mb-20 scroll-mt-20">
            <h2 class="text-3xl font-bold text-center mb-4">Node.js 마스터 로드맵</h2>
            <p class="text-center text-gray-600 max-w-3xl mx-auto mb-12">성공적인 Node.js 개발자로 성장하기 위한 체계적인 학습 경로를 제시합니다. 각 단계를 클릭하여 무엇을 배워야 하는지 확인하고, 비동기 처리 방식의 발전을 한눈에 비교해보세요.</p>
            <div class="flex flex-col md:flex-row">
                <div class="md:w-1/4">
                    <ul id="roadmap-steps" class="space-y-2">
                        <li data-step="1" class="roadmap-step cursor-pointer p-4 rounded-lg font-bold bg-blue-500 text-white">1단계: 선수 지식 습득</li>
                        <li data-step="2" class="roadmap-step cursor-pointer p-4 rounded-lg font-bold bg-gray-200">2단계: 환경 구축 및 기초</li>
                        <li data-step="3" class="roadmap-step cursor-pointer p-4 rounded-lg font-bold bg-gray-200">3단계: 프레임워크와 API</li>
                        <li data-step="4" class="roadmap-step cursor-pointer p-4 rounded-lg font-bold bg-gray-200">4단계: 실전 및 심화</li>
                    </ul>
                </div>
                <div class="md:w-3/4 md:pl-8 mt-8 md:mt-0">
                    <div id="roadmap-content" class="section-card p-8 min-h-[250px]">
                    </div>
                </div>
            </div>
        </section>

        <hr class="my-16 border-gray-200">

        <section id="mistakes" class="scroll-mt-20">
            <h2 class="text-3xl font-bold text-center mb-4">초보자가 흔히 저지르는 실수</h2>
            <p class="text-center text-gray-600 max-w-3xl mx-auto mb-12">누구나 처음에는 실수를 합니다. 가장 흔한 실수들을 미리 알아보고, 어떻게 해결할 수 있는지 배워서 더 빠른 성장을 이뤄보세요. 각 항목을 클릭하여 자세한 내용을 확인하세요.</p>
            <div id="accordion" class="max-w-3xl mx-auto space-y-4">
                <div class="accordion-item bg-white rounded-lg shadow-md">
                    <button class="accordion-header w-full text-left p-4 font-bold text-lg flex justify-between items-center">
                        <span>이벤트 루프 블로킹: Sync 메소드의 함정</span>
                        <span>▼</span>
                    </button>
                    <div class="accordion-content px-4 pb-4">
                        <p class="text-gray-700">`fs.readFileSync`와 같은 동기 메소드는 I/O 작업이 끝날 때까지 메인 스레드를 멈춥니다. 이는 모든 요청 처리를 지연시켜 Node.js의 최대 장점인 비동기 처리 능력을 무력화합니다. 항상 `fs.readFile`과 같은 비동기 메소드를 사용하고 콜백, Promise, async/await로 결과를 처리해야 합니다.</p>
                    </div>
                </div>
                 <div class="accordion-item bg-white rounded-lg shadow-md">
                    <button class="accordion-header w-full text-left p-4 font-bold text-lg flex justify-between items-center">
                        <span>콜백 헬(Callback Hell)</span>
                        <span>▼</span>
                    </button>
                    <div class="accordion-content px-4 pb-4">
                        <p class="text-gray-700">비동기 콜백 함수가 계속 중첩되어 코드의 가독성과 유지보수성이 급격히 떨어지는 현상입니다. 이는 `Promise`나 `async/await` 문법을 사용하여 해결할 수 있습니다. 코드를 순차적으로 보이게 만들어 훨씬 깔끔하고 이해하기 쉬운 코드를 작성할 수 있습니다.</p>
                    </div>
                </div>
                 <div class="accordion-item bg-white rounded-lg shadow-md">
                    <button class="accordion-header w-full text-left p-4 font-bold text-lg flex justify-between items-center">
                        <span>`exports`와 `module.exports`의 혼동</span>
                        <span>▼</span>
                    </button>
                    <div class="accordion-content px-4 pb-4">
                        <p class="text-gray-700">`exports`는 `module.exports`를 가리키는 참조 변수일 뿐입니다. `exports.myFunc = ...` 처럼 속성을 추가하는 것은 괜찮지만, `exports = myFunc`처럼 객체 자체를 할당하면 참조가 끊어져 모듈이 제대로 동작하지 않습니다. 모듈의 API를 객체 형태로 내보낼 때는 항상 `module.exports`에 직접 할당하는 것이 안전합니다.</p>
                    </div>
                </div>
            </div>
        </section>

    </main>

    <footer class="bg-gray-800 text-white mt-20">
        <div class="container mx-auto px-6 py-8 text-center">
            <p>&copy; 2024 Node.js Interactive Guide. All Rights Reserved.</p>
            <p class="text-sm text-gray-400 mt-2">이 페이지는 교육 목적으로 제작되었습니다.</p>
        </div>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            
            const mobileMenuButton = document.getElementById('mobile-menu-button');
            const mobileMenu = document.getElementById('mobile-menu');
            mobileMenuButton.addEventListener('click', () => {
                mobileMenu.classList.toggle('hidden');
            });

            const navLinks = document.querySelectorAll('.nav-link');
            const sections = document.querySelectorAll('section');
            
            window.addEventListener('scroll', () => {
                let current = '';
                sections.forEach(section => {
                    const sectionTop = section.offsetTop;
                    if (pageYOffset >= sectionTop - 100) {
                        current = section.getAttribute('id');
                    }
                });

                navLinks.forEach(link => {
                    link.classList.remove('active');
                    if (link.getAttribute('href').substring(1) === current) {
                        link.classList.add('active');
                    }
                });
            });

            const callStackEl = document.getElementById('call-stack');
            const webApisEl = document.getElementById('web-apis');
            const callbackQueueEl = document.getElementById('callback-queue');
            const runSimulationBtn = document.getElementById('run-simulation');
            const simulationLogEl = document.getElementById('simulation-log');

            function createTaskElement(text) {
                const div = document.createElement('div');
                div.className = 'task';
                div.textContent = text;
                return div;
            }

            function log(message) {
                simulationLogEl.textContent = message;
            }

            runSimulationBtn.addEventListener('click', () => {
                runSimulationBtn.disabled = true;
                callStackEl.innerHTML = '';
                webApisEl.innerHTML = '';
                callbackQueueEl.innerHTML = '';
                log('');

                setTimeout(() => {
                    const task1 = createTaskElement('main()');
                    callStackEl.appendChild(task1);
                    log('메인 스크립트 실행');
                }, 500);

                setTimeout(() => {
                    const task2 = createTaskElement('readFile()');
                    callStackEl.appendChild(task2);
                    log('비동기 함수 readFile() 호출');
                }, 1500);
                
                setTimeout(() => {
                    const task2 = callStackEl.querySelector('.task:last-child');
                    webApisEl.appendChild(task2);
                    task2.textContent = '파일 읽는 중... (3초)';
                    log('readFile() 작업을 libuv에 위임');
                }, 2500);

                setTimeout(() => {
                    const task1 = callStackEl.querySelector('.task');
                    task1.remove();
                    log('메인 스크립트 실행 완료, 콜 스택 비워짐');
                }, 3500);

                setTimeout(() => {
                    const task2 = webApisEl.querySelector('.task');
                    task2.remove();
                    const callbackTask = createTaskElement('readFile 콜백');
                    callbackQueueEl.appendChild(callbackTask);
                    log('파일 읽기 완료, 콜백 함수가 큐로 이동');
                }, 5500);

                setTimeout(() => {
                    log('이벤트 루프가 콜 스택이 비어있음을 확인');
                }, 6000);

                setTimeout(() => {
                    const callbackTask = callbackQueueEl.querySelector('.task');
                    callbackTask.remove();
                    callStackEl.appendChild(callbackTask);
                    log('큐의 콜백 함수를 콜 스택으로 이동하여 실행');
                }, 6500);

                setTimeout(() => {
                    const callbackTask = callStackEl.querySelector('.task');
                    callbackTask.remove();
                    log('콜백 함수 실행 완료. 시뮬레이션 종료.');
                    runSimulationBtn.disabled = false;
                }, 7500);
            });

            const roadmapData = {
                1: {
                    title: "1단계: 필수 선수 지식 습득",
                    content: "Node.js는 자바스크립트 런타임이므로, 자바스크립트 기본 문법 숙지는 필수입니다. 특히 비동기 처리의 핵심인 <strong>콜백, Promise, async/await</strong>를 깊이 이해해야 합니다. 또한 웹의 기본 동작 원리인 <strong>HTTP 프로토콜과 RESTful API</strong> 개념을 익혀야 합니다."
                },
                2: {
                    title: "2단계: 개발 환경 구축 및 기초 다지기",
                    content: "Node.js를 설치하고, <strong>`npm init`</strong>으로 프로젝트를 시작합니다. <strong>`http`</strong> 내장 모듈을 사용해 간단한 웹 서버를 직접 만들어보며 요청(req)과 응답(res)의 흐름을 이해하는 것이 중요합니다. <strong>CommonJS</strong> 모듈 시스템도 함께 학습합니다."
                },
                3: {
                    title: "3단계: 핵심 프레임워크와 API 개발",
                    content: "<strong>Express.js</strong>와 같은 웹 프레임워크를 학습하여 라우팅, 미들웨어 등 복잡한 서버 기능을 효율적으로 구현합니다. 이를 바탕으로 RESTful API를 설계하고, <strong>MongoDB나 PostgreSQL</strong> 같은 데이터베이스와 연동하여 실제 데이터를 다루는 방법을 익힙니다."
                },
                4: {
                    title: "4단계: 실전 프로젝트와 심화 학습",
                    content: "웹소켓을 이용한 실시간 채팅 앱이나 CLI 도구 등 실전 프로젝트를 진행하며 문제 해결 능력을 기릅니다. <strong>Jest</strong>를 이용한 테스트 코드 작성, <strong>Docker</strong>를 이용한 컨테이너화, <strong>pm2</strong>를 이용한 프로세스 관리 및 배포 등 실무 역량을 강화합니다."
                }
            };

            const roadmapSteps = document.getElementById('roadmap-steps');
            const roadmapContentEl = document.getElementById('roadmap-content');

            function updateRoadmapContent(step) {
                const data = roadmapData[step];
                roadmapContentEl.innerHTML = `<h3 class="text-xl font-bold mb-4">${data.title}</h3><p class="text-gray-700">${data.content}</p>`;
                roadmapContentEl.classList.add('fade-in');
                setTimeout(() => roadmapContentEl.classList.remove('fade-in'), 500);

                roadmapSteps.querySelectorAll('.roadmap-step').forEach(el => {
                    el.classList.remove('bg-blue-500', 'text-white');
                    el.classList.add('bg-gray-200');
                });
                roadmapSteps.querySelector(`[data-step="${step}"]`).classList.add('bg-blue-500', 'text-white');
                roadmapSteps.querySelector(`[data-step="${step}"]`).classList.remove('bg-gray-200');
            }

            roadmapSteps.addEventListener('click', (e) => {
                const stepEl = e.target.closest('.roadmap-step');
                if (stepEl) {
                    const step = stepEl.dataset.step;
                    updateRoadmapContent(step);
                }
            });
            
            updateRoadmapContent(1);

            const accordionHeaders = document.querySelectorAll('.accordion-header');
            accordionHeaders.forEach(header => {
                header.addEventListener('click', () => {
                    const content = header.nextElementSibling;
                    const item = header.parentElement;
                    const icon = header.querySelector('span:last-child');

                    item.classList.toggle('open');
                    
                    if (item.classList.contains('open')) {
                        content.style.maxHeight = content.scrollHeight + 'px';
                        icon.style.transform = 'rotate(180deg)';
                    } else {
                        content.style.maxHeight = '0';
                        icon.style.transform = 'rotate(0deg)';
                    }
                });
            });

            const ctx = document.getElementById('performanceChart').getContext('2d');
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['I/O-Bound (1000개 파일 읽기)', 'CPU-Bound (복잡한 연산 1000회)'],
                    datasets: [{
                        label: '블로킹 방식 (ms)',
                        data: [5500, 4000],
                        backgroundColor: 'rgba(255, 99, 132, 0.5)',
                        borderColor: 'rgba(255, 99, 132, 1)',
                        borderWidth: 1
                    }, {
                        label: 'Node.js 논블로킹 방식 (ms)',
                        data: [800, 3900],
                        backgroundColor: 'rgba(54, 162, 235, 0.5)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: '작업 유형에 따른 처리 시간 비교'
                        },
                        tooltip: {
                            callbacks: {
                                footer: (tooltipItems) => {
                                    if (tooltipItems[0].label.startsWith('I/O')) {
                                        return 'Node.js는 I/O 작업을 기다리지 않고 다음 요청을 처리하여 매우 효율적입니다.';
                                    }
                                    return 'CPU 집약적 작업에서는 단일 스레드 특성상 큰 이점이 없습니다.';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: '소요 시간 (ms)'
                            }
                        }
                    }
                }
            });
        });
    </script>
</body>
</html>
